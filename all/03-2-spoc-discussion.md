# lec6 SPOC思考题


NOTICE
- 有"w3l2"标记的题是助教要提交到学堂在线上的。
- 有"w3l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 与视频相关思考题

### 6.1	非连续内存分配的需求背景
 1. 为什么要设计非连续内存分配机制？  
答：  
提高分配的灵活性  
提高内存的利用效率：方便共享、充分利用内存空间

 1. 非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变?  
答：  
大块：方便管理  
小块：更加灵活，利用率更高  
最好以某统一大小为单位，简化管理过程，也能适应不同需求  

 1. 为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？  
答：  
固定大小好管理，多种大小比一种大小灵活  
可变大小更灵活，通常可变大小也会通过对齐来减少管理难度  
  
### 6.2	段式存储管理
 1. 什么是段、段基址和段内偏移？  
答：  
段：访问方式和存储的数据等属性相同的一段地址空间  
段基址：一个段所处的连续内存空间的起始地址  
段内偏移：某地址在其所处段内，相对段基址的偏移量  

 1. 段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？  
答：  
地址转换：段基址+段内偏移
每个段为一个连续地址空间，但各段有自己的段基址，因此各段不必连续，段内任意地址可以根据其所处段自己的段基址进行访问  
好处：允许不连续内存管理，更加灵活，方便管理  麻烦：地址转换较复杂


### 6.3	页式存储管理
 1. 什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？  
答：  
页：即页面或逻辑页面，把逻辑地址空间划分为相同大小的基本分配单位，每个单位称为一页  
帧：即页帧或物理页面，把物理地址空间划分为相同大小的基本分配单位，每个单位称为一帧  
页表：记录页面的逻辑地址到页帧的物理地址的转换的、存放于内存中的、定义这种对应关系的表  
MMU：位于CPU中，CPU需要访问内存时，通过MMU将逻辑地址转换为物理地址  
TLB：对页表项的缓存，需要访问页表时会先访问TLB，如果存在需要的对应项则直接映射，否则访问页表，并通过置换算法将新访问的页表项替换入TLB中  
Cache：对内存存储内容的缓存，访问内存时，根据MMU产生的物理地址先查找Cache，若命中则直接使用Cache内容，否则进一步访存并将内存内容替换进Cache  

 1. 页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各页的存储位置可以不连续？这种做法有什么好处和麻烦？  
答：  
转换流程：根据进程，从其自己的页表中根据逻辑地址中的页号查找页表项，取出帧号，再合并页内偏移成为物理地址  
不同页由页号对应的帧号，这种对应关系由页表确定，不同页对应的帧号可以不连续，因此页的存储位置可以不连续  
好处：方便管理，更加灵活；麻烦：地址转换比较麻烦，而且页表需要占用存储空间，且访问页表需要访存，开销大  


### 6.4	页表概述
 1. 每个页表项有些什么内容？有哪些标志位？它们起什么作用？  
答：  
页表项内容：帧号+标志位  
标志位  
存在位：该页是否实际存在于物理内存中  
修改位：该页是否被写入过   
引用位：该页内容是否被进程使用；若有多位引用位，则还可以用于替换算法使用  

 1. 页表大小受哪些因素影响？  
答：  
页大小、逻辑地址空间大小、进程数目  


### 6.5	快表和多级页表
 1. 快表（TLB）与高速缓存（cache）有什么不同？  
答：  
TLB：页表项的缓存  
Cache：内存中存储内容的缓存  

 1. 为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？  
答：  
因为TLB使用关联存储实现，其中缓存有部分页号和帧号的对应，如果TLB命中，则可以不经过访问页表就获得物理地址，避免了访存；如果没有命中，对应的表项在查找页表后也将替换进TLB中。因此速度快  
实现：存储页号到帧号的映射，使用关联存储实现，可以快速访问  
容量小：一方面，TLB位于CPU中，不可能做的太大；另一方面，也是很重要的原因，在于较小的空间能提高查找、比对速度，而且如果容量过大还会降低命中率  

 1. 什么是多级页表？多级页表中的地址转换流程是什么？多级页表有什么好处和麻烦？  
答：  
多级页表：将逻辑地址的页号通过间接引用划分为多级，将不同级对应的页表分层次组织，逐级向下  
转换流程：从最高级页号开始，查找对应页表，取出其对应的下一级页表基地址，加上下一级页号即为下一级页表项地址，依次向下查找，直到末级页表中为页表项，从中取出帧号，与逻辑地址中的页内偏移组合成物理地址  
好处：在页没有被全部分配时，能有效减少页表大小，未使用的页可以不为之建立页表项；麻烦：多级查找，多次访存，开销大  


### 6.6	反置页表
 1. 页寄存器机制的地址转换流程是什么？  
答：  
对逻辑页号进行Hash映射，查找结果对应的页寄存器，若冲突则查找下一个，找到对应的页寄存器后，物理帧号即为该寄存器对应的物理帧。  

 1. 反置页表机制的地址转换流程是什么？  
答：  
对页号和进程标识一起Hash，用结果作为页表项索引查找页表项，比对PID和页号，若一致则物理帧号就是索引号，若不一致说明冲突，利用页表项的next内容查找下一页表项  

 1. 反置页表项有些什么内容？  
答：  
PID，逻辑页号，下一页表项索引，标志位  

### 6.7	段页式存储管理
 1. 段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？  
答：  
从逻辑地址取出段号，加上该进程的段表基址找到对应的段表项，取出对应的页表基址，再加上逻辑地址中的页号得到页表项，从页表中查到其物理帧号，加上逻辑地址中的offset得到物理地址  
好处：兼顾段式存储的内存保护优势和页式存储的内存利用、优化转移、虚拟化优势；  
麻烦：地址转换复杂，需要先后访问段表和页表才能得到物理地址  

 1. 如何实现基于段式存储管理的内存共享？  
答：  
共享段指向共同的页表  

 1. 如何实现基于页式存储管理的内存共享？  
答：  
需要共享的页号指向同一物理帧  


## 个人思考题
（1） (w3l2) 请简要分析64bit CPU体系结构下的分页机制是如何实现的



## 小组思考题
（1）(spoc) 某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10^-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10^-6s),求不在内存的页面的平均访问时间。请给出计算步骤。



（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示映射不存在。
PFN6..0:页帧号
PT6..0:页表的物理基址>>5
```
在[物理内存模拟数据文件](./03-2-spoc-testdata.md)中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。
```
1) Virtual Address 6c74
   Virtual Address 6b22
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```

比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)
```
Virtual Address 7570:
  --> pde index:0x1d  pde contents:(valid 1, pfn 0x33)
    --> pte index:0xb  pte contents:(valid 0, pfn 0x7f)
      --> Fault (page table entry not valid)

Virtual Address 21e1:
  --> pde index:0x8  pde contents:(valid 0, pfn 0x7f)
      --> Fault (page directory entry not valid)

Virtual Address 7268:
  --> pde index:0x1c  pde contents:(valid 1, pfn 0x5e)
    --> pte index:0x13  pte contents:(valid 1, pfn 0x65)
      --> Translates to Physical Address 0xca8 --> Value: 16
```

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，请说明原因。

（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，提交你的实现，并说明区别。

（4）假设你有一台支持[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。

 (5)[X86的页面结构](http://os.cs.tsinghua.edu.cn/oscourse/OS2019spring/lecture06)
---

## 扩展思考题

阅读64bit IBM Powerpc CPU架构是如何实现[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)，给出分析报告。


## interactive　understand VM

[Virtual Memory with 256 Bytes of RAM](http://blog.robertelder.org/virtual-memory-with-256-bytes-of-ram/)：这是一个只有256字节内存的一个极小计算机系统。按作者的[特征描述](https://github.com/RobertElderSoftware/recc#what-can-this-project-do)，它具备如下的功能。
 - CPU的实现代码不多于500行；
 - 支持14条指令、进程切换、虚拟存储和中断；
 - 用C实现了一个小的操作系统微内核可以在这个CPU上正常运行；
 - 实现了一个ANSI C89编译器，可生成在该CPU上运行代码；
 - 该编译器支持链接功能；
 - 用C89, Python, Java, Javascript这4种语言实现了该CPU的模拟器；
 - 支持交叉编译；
 - 所有这些只依赖标准C库。
 
针对op-cpu的特征描述，请同学们通过代码阅读和执行对自己有兴趣的部分进行分析，给出你的分析结果和评价。
